#' Make a deviance plot
#'
#' This makes a deviance plot which plots residual deviance (dev_arm) vs. all the arms for each study.
#' @param result Object created by \code{\link{network.run}} function
#' @examples
#' network <- with(blocker, {
#'  network.data(Outcomes, Study, Treat, N = N, response = "binomial")
#' })
#' result <- network.run(network)
#' network.deviance.plot(result)
#' @export
network.deviance.plot <- function(result){
deviance <- result$deviance
dev_vector <- c(t(deviance$dev_arm))
dev_vector <- dev_vector[!is.na(dev_vector)]
plot(seq(sum(result$network$na)), dev_vector, xlab = "Arm", ylab = "Residual Deviance", main = "Per-arm residual deviance")
}
#' Make a leverage plot
#'
#' This function makes a leverage vs. square root of residual deviance plot
#'
#' @param result Object created by \code{\link{network.run}} function
#' @export
network.leverage.plot <- function(result){
deviance <- result$deviance
dev <- sqrt(apply(deviance$dev_arm, 1, mean, na.rm = TRUE))
leverage <- apply(deviance$leverage, 1, mean, na.rm = TRUE)
plot(dev, leverage, xlim = c(0, max(c(dev, 2.5))), ylim = c(0, max(c(leverage,4))),
xlab = "Square root of residual deviance", ylab = "Leverage", main = "Leverage versus residual deviance")
mtext("Per-study mean per-datapoint contribution")
}
#' Make a covariate plot
#'
#' This function makes a covariate plot of how the relative effect changes as the covariate value changes.
#' User needs to specify one base treatment and one comparison treatment to make this plot (base category and comparison category is also needed for multinomial).
#' The function uses the \code{\link{relative.effects}} to calculate the correct relative effect. 2.5\%, median, and 97.5\% C.I. are drawn.
#'
#' @param result Object created by \code{\link{network.run}} function
#' @param base.treatment Base treatment for relative effect
#' @param comparison.treatment Treatment comparing against base treatment
#' @param base.category Base category for multinomial data. Note that category in multinomial denotes which column it is in the Outcomes matrix. Thus, this should be a numeric value.
#' @param comparison.category Comparison category for multinomial data
#' @param covariate.name A vector of covariate names of the covariate that goes into x-axis label
#' @examples
#' ########### certolizumab (with covariate)
#' network <- with(certolizumab, {
#'  network.data(Outcomes, Study, Treat, N=N, response="binomial", Treat.order,
#'  covariate = covariate, hy.prior = list("dhnorm", 0, 9.77))
#' })
#' result <- network.run(network)
#' network.covariate.plot(result, base.treatment = "Placebo", comparison.treatment = "CZP",
#' covariate.name = "Disease Duration")
#' @export
network.covariate.plot <- function(result, base.treatment = NULL, comparison.treatment= NULL, base.category = NULL, comparison.category = NULL, covariate.name = NULL){
if(is.null(network$covariate)){
stop("need to provide covariate information to make this plot")
}
if(result$network$response != "multinomial"){
if(is.null(base.treatment) || is.null(comparison.treatment)){
stop("need to specify both base.treatment and comparison.treatment")
}
} else{
if(is.null(base.treatment) || is.null(comparison.treatment) || is.null(base.category) || is.null(comparison.category)){
stop("need to specify all base.treatment, comparison.treatment, base.category, and comparison.category")
}
}
network <- result$network
observed <- network$covariate
xvals <- matrix(NA, nrow = dim(network$covariate)[2], ncol = 7)
xlim <- matrix(NA, nrow = dim(network$covariate)[2], ncol = 2)
covariate_mx <- NULL
for(i in 1:dim(network$covariate)[2]){
xlim[i,] <- c(min(observed[,i], na.rm = TRUE), max(observed[,i], na.rm = TRUE))
xvals[i,] <- seq(xlim[i,1], xlim[i,2], length.out = 7)
covariate_mx <- c(covariate_mx, network[[paste0("mx",i)]])
}
for(i in 1:dim(network$covariate)[2]){
res <- lapply(xvals[i,], function(xval) {
covariate <- covariate_mx
covariate[i] <- xval
if(network$response != "multinomial"){
samples <- relative.effects(result, base.treatment, comparison.treatment, covariate = covariate)
} else{
samples <- relative.effects(result, base.treatment, comparison.treatment, base.category, comparison.category, covariate = covariate)
}
samples <- as.matrix(samples)
stats <- t(apply(samples, 2, quantile, probs = c(0.025, 0.5, 0.975)))
data.frame(median = stats[,"50%"], lower = stats[,"2.5%"], upper = stats[,"97.5%"])
})
res <- do.call(rbind,res)
dim_names <- if(network$response != "multinomial"){
dimnames(as.matrix(relative.effects(result, base.treatment, comparison.treatment)))[[2]]
} else{
dimnames(as.matrix(relative.effects(result, base.treatment, comparison.treatment, base.category, comparison.category)))[[2]]
}
ylim <- c(min(res), max(res))
xlab_name <- ifelse(is.null(covariate.name), paste0("covariate ", i), covariate.name[i])
plot(xvals[i,], res$median, type = "l", xlim = xlim[i,], ylim = ylim, main = "Treatment effect vs. covariate", xlab = xlab_name, ylab = dim_names)
lines(xvals[i,], res$lower, lty = 2)
lines(xvals[i,], res$upper, lty = 2)
}
}
#' Calculate correlation matrix for multinomial heterogeneity parameter.
#'
#' This function calculates correlation matrix from the variance matrix for heterogeneity parameter. Only used for multinomial.
#' @param result Object created by \code{\link{network.run}} function
#' @examples
#' #cardiovascular
#' network <- with(cardiovascular, {
#'  network.data(Outcomes, Study, Treat, N, response = "multinomial")
#' })
#' result <- network.run(network)
#' variance.tx.effects(result)
#' @export
variance.tx.effects = function(result)
{
if(result$network$response != "multinomial"){
stop("this function is used only for multinomial response")
}
samples_sigma <- pick.summary.variables(result, only.pars = c("sigma"))
samples_sigma <- do.call(rbind, samples_sigma)
samples_sigma <- apply(samples_sigma, 2, mean)
sigma_matrix <- matrix(samples_sigma, nrow = result$network$ncat-1)
cor_matrix <- sigma_matrix/outer(sqrt(diag(sigma_matrix)),sqrt(diag(sigma_matrix)))
return(list(sigma_matrix = sigma_matrix, cor_matrix = cor_matrix))
}
#' Draws forest plot
#'
#' Draws forest plot of pooled treatment effect. Reports odds ratio for binomial and multinomial outcomes and continuous scale for normal outcomes.
#'
#' @param result Object created by \code{\link{network.run}} function
#' @param level Confidence level. Default is 0.95 denoting 95 percent C.I.
#' @param ticks.position Position of the x-axis tick marks. If left unspecified, the function tries to set it at sensible values
#' @param label.multiplier This is a multiplying factor to move the position of the text associated with median[lower, upper] values. This number is multiplied by the range of x-axis and added to the x-axis limit. Default multiplier is set to 0.2.
#' @param label.margin This is how much margin space you specify to assign space for the median[lower, upper] values. Default margin is set to 10.
#' @references W. Viechtbauer (2010), \emph{Conducting meta-analyses in R with the metafor package}, Journal of Statistical Software, 36(3):1-48. [\url{https://doi.org/10.18637/jss.v036.i03}]
#' @export
network.forest.plot <- function(result, level = 0.95, ticks.position = NULL, label.multiplier = 0.2, label.margin = 10){
ncat <- ifelse(result$network$response == "multinomial", result$network$ncat, 2)
for(i in 1:(ncat-1)){
if(i != 1) grid::grid.newpage()
if(result$network$response == "multinomial"){
lower <- relative.effects.table(result, summary_stat = "quantile", probs = (1- level)/2)[,,i]
OR <- relative.effects.table(result, summary_stat = "quantile", probs = 0.5)[,,i]
upper <- relative.effects.table(result, summary_stat = "quantile", probs = level + (1- level)/2)[,,i]
} else{
lower <- relative.effects.table(result, summary_stat = "quantile", probs = (1- level)/2)
OR <- relative.effects.table(result, summary_stat = "quantile", probs = 0.5)
upper <- relative.effects.table(result, summary_stat = "quantile", probs = level + (1- level)/2)
}
lower <- lower[upper.tri(lower)]
OR <- OR[upper.tri(OR)]
upper <- upper[upper.tri(upper)]
odds <- data.frame(lower = lower, OR = OR, upper = upper)
if(result$network$response %in% c("binomial", "multinomial")){
odds <- exp(odds) #report odds ratio instead of log odds ratio
}
Treat.order <- result$network$Treat.order
ts <- 1:length(Treat.order)
comps <- combn(ts, 2)
name <- rep(NA, ncol(comps))
for(j in 1:ncol(comps)){
name[j] <- paste0(Treat.order[comps[2,j]]," vs ", Treat.order[comps[1,j]])
}
odds$name <- name
if(is.null(ticks.position)){
if(result$network$response %in% c("binomial", "multinomial")){
ticks <- c(0.1, 0.2, 0.5, 1, 2, 5, 10)
} else if(result$network$response == "normal"){
ticks <- pretty(c(min(odds$lower, na.rm =TRUE), max(odds$upper, na.rm = TRUE)))
}
} else{
ticks <- ticks.position
}
p <- ggplot(odds, aes(y = OR, x = name)) +
geom_point() +
geom_errorbar(aes(ymin = lower, ymax = upper), width = .2) +
scale_x_discrete(limits = name) +
geom_hline(yintercept = 1, linetype = 2) +
coord_flip() +
theme_bw() +
theme(plot.margin = unit(c(1,label.margin,1,1), "lines"))
if(result$network$response %in% c("binomial")){
p <- p + labs(x = "Treatment comparison", y = "Odds Ratio", title = "Network Meta-analysis Forest plot") +
scale_y_log10(breaks = ticks, labels = ticks)
} else if(result$network$response %in% c("multinomial")){
p <- p + labs(x = "Treatment comparison", y = "Odds Ratio", title = paste0("Network Meta-analysis Forest plot", ": Multinomial Category ", (i+1), " vs 1")) +
scale_y_log10(breaks = ticks, labels = ticks)
} else if(result$network$response %in% c("normal")){
p <- p + labs(x = "Treatment comparison", y = "Continuous Scale", title = "Network Meta-analysis Forest plot") +
scale_y_continuous(breaks = ticks, labels = ticks)
}
#find actual xlim range; this part of code keeps changing with ggplot update..
xlim.range <- ggplot_build(p)$layout$panel_params[[1]]$x.range
p <- p + geom_text(aes(label = paste0(sprintf("%0.2f", round(OR, digits = 2)), " [", sprintf("%0.2f", round(lower, digits = 2)) , ", ", sprintf("%0.2f", round(upper, digits = 2)), "]")), y = xlim.range[2] + diff(xlim.range)*label.multiplier, x = 1:length(comps[1,]))   # hjust = -1, vjust = 2)
median_name_location <- ifelse(length(odds[,1]) <= 3, length(comps[1,]) + 0.5, length(comps[1,]) + 1)
p <- p + geom_text(aes(label = "Median [lower, upper]"), y = xlim.range[2] + diff(xlim.range)*label.multiplier, x = median_name_location)
gt <- ggplot_gtable(ggplot_build(p))
gt$layout$clip[gt$layout$name == "panel"] <- "off"
grid::grid.draw(gt)
}
}
#' Draws network graph using igraph package
#'
#' This function draws network graph using igraph package
#' @param network Object created by \code{\link{network.data}} function
#' @examples
#' #cardiovascular
#' network <- with(thrombolytic, {
#'  network.data(Outcomes, Study, Treat, N=N, response = "binomial")
#' })
#' draw.network.graph(network)
#' @export
draw.network.graph = function(network){
if(class(network) == "contrast.network.data"){
Treat <- c(t(network$Treat))[!is.na(c(t(network$Treat)))]
Study <- rep(1:length(network$na), times = network$na)
} else{
Treat <- network$Treat
Study <- network$Study
}
pairs <- do.call(rbind, lapply(split(Treat, Study),
function(x) t(combn(x,2))))
pairs <- aggregate(rep(1, length(X1)) ~ X1 + X2, data = data.frame(pairs), sum)
g <- igraph::graph.edgelist(as.matrix(pairs[,1:2]), directed=FALSE)
plot(g, edge.curved=FALSE, edge.width=pairs$freq, vertex.label.dist=.7)
}
result <- network.run(network)
summary(Result)
summary(result)
network
str(network)
blocker
smoking
network <- with(smoking, network.data(Outcomes = Outcomes, Study = Study, Treat = Treat, N = N, response = "binomial", mean.d = 0.1, hy.prior = list("dhnorm", 0, 1)))
cat(network$code)
network <- with(smoking, network.data(Outcomes = Outcomes, Study = Study, Treat = Treat, N = N, response = "binomial", mean.d = 0.1, hy.prior = list("dhnorm", 0, 5)))
result <- network.run(network, n.runs = 60000)
result <- network.run(network, n.run = 60000)
network.forest.plot(result)
library(ggplot2)
network.forest.plot(result)
devtools::install_github("MikeJSeo/bnma")
network.run
devtools::install_github("MikeJSeo/bnma")
devtools::install_github("MikeJSeo/bnma")
library(bnma)
network.run
setwd("~/GitHub/bnma")
devtools::doument()
devtools::document()
devtools::install_github("MikeJSeo/bnma")
network.run
network <- with(smoking, network.data(Outcomes = Outcomes, Study = Study, Treat = Treat, N = N, response = "binomial", mean.d = 0.1, hy.prior = list("dhnorm", 0, 5)))
network
result <- network.run(network, n.run = 60000)
str(network)
devtools::install_github("MikeJSeo/bnma")
library(bnma)
network <- with(blocker, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial")
})
network
devtools::install_github("MikeJSeo/bnma")
library(bnma)
network.data
network.data <- function(Outcomes = NULL, Study = NULL, Treat = NULL, N = NULL, SE = NULL, response = NULL, Treat.order = NULL, type = "random", rank.preference = "higher",
baseline = "none", baseline.risk = "independent", covariate = NULL, covariate.type = NULL, covariate.model = NULL,
mean.d = NULL, prec.d = NULL, mean.Eta = NULL, prec.Eta = NULL, hy.prior.Eta = NULL, mean.bl = NULL, prec.bl = NULL, hy.prior.bl = NULL,
mean.cov = NULL, prec.cov = NULL, hy.prior.cov = NULL, hy.prior = NULL) {
# rename the variables and order them based on specified treatment order
network <- preprocess.data(Outcomes = Outcomes, Study = Study, Treat = Treat, N = N, SE = SE, response = response, Treat.order = Treat.order, type = type, rank.preference = rank.preference,
baseline = baseline, baseline.risk = baseline.risk, covariate = covariate, covariate.type = covariate.type, covariate.model = covariate.model,
hy.prior.Eta = hy.prior.Eta, hy.prior.bl = hy.prior.bl, hy.prior.cov = hy.prior.cov, hy.prior = hy.prior)
# find characteristic values associated with the network, i.e. number of studies, number of treatments, etc
characteristics <- find.characteristics(network)
network <- append(network, characteristics)
# change input dimensions for Outcomes, Study, Treat, and N/SE to fit JAGS coding format
new.inputs <- change.dimensions(network)
network <- append(network, new.inputs)
# generate default priors for heterogeneity if not specified
hy.prior <- hy.prior.update(network, hy.prior.Eta, hy.prior.bl, hy.prior.cov, hy.prior)
network <- append(network, hy.prior)
# generate prior data that will be used for running JAGS model
prior.data <- network.prior.default(network, mean.d, prec.d, mean.Eta, prec.Eta, hy.prior.Eta, mean.bl, prec.bl, hy.prior.bl, mean.cov, prec.cov, hy.prior.cov, hy.prior)
network <- append(network, prior.data)
network$prior.data <- prior.data
# generate JAGS code
code <- network.rjags(network)
network$code <- code
class(network) <- "network.data"
return(network)
}
network <- with(blocker, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial")
})
network$prior.data
network
cat(network$code)
network$prior.data
network$prior.data
str(network)
cat(network$code)
store <- list()
#' Make a network object containing data, priors, and a JAGS model file
#'
#' This function makes a network object that can be used to run network meta-analysis using \code{\link{network.run}}.
#' User needs to specify Outcomes, Study, Treat, N or SE, and response.
#' Prior parameters are filled in automatically based on the data type if not specified.
#' The input data should be arm-level so that we have observations for each treatment in each study.
#' The input data is preprocessed to fit the format necessary to run model in JAGS.
#'
#' @param Outcomes Arm-level outcomes. If it is a multinomial response, the matrix would have dimensions treatment arms (row) by multinomial categories (column). If it is binomial or normal, it would be a vector.
#' @param Study A vector of study indicator for each arm
#' @param Treat A vector of treatment indicator for each arm
#' @param N A vector of total number of observations in each arm. Used for binomial and multinomial responses.
#' @param SE A vector of standard error for each arm. Used only for normal response.
#' @param response Specification of the outcomes type. Must specify one of the following: "normal", "binomial", or "multinomial".
#' @param Treat.order Treatment order which determines how treatments are compared. The first treatment that is specified is considered to be the baseline treatment. Default order is alphabetical. If the treatments are coded 1, 2, etc, then the treatment with a value of 1 would be assigned as a baseline treatment.
#' @param type Type of model fitted: either "random" for random effects model or "fixed" for fixed effects model. Default is "random".
#' @param rank.preference Set it equal to "higher" if higher values are preferred (i.e. assumes events are good). Set it equal to "lower" if lower values are preferred (i.e. assumes events are bad). Default is "higher".
#' @param baseline Three different assumptions for treatment x baseline risk interactions (slopes): "independent", "common", or "exchangeable". Default is "none" which doesn't incorporate baseline risk.
#' @param baseline.risk Two different assumptions for baseline risk: "independent" or "exchangeable". See Achana et al. (2012) for more information about baseline risk.
#' @param covariate A covariate matrix with each row representing each trial and column representing each covariate. This is a study-level data, meaning that the user doesn't need to repeatedly specify covariates for each arm.
#' @param covariate.type Should be a vector indicating the type of the covariate. Covariate can be either "continuous" or "discrete". If it continuous, covariates are centered. If the covariate is discrete it is not centered and it has to be in a dummy integer format (i.e. 0,1,2,...). The code doesn't factor the covariates for the user, so user needs to specify dummy variables if factor is needed.
#' @param covariate.model "independent" allows covariate effects for each treatment. "common" restricts same covariate effect for all treatment. Lastly, "exchangeable"  assumes that the covariate effects are different but related and strength is borrowed across them. We set "common" to be default. See Cooper et al. (2009) for more details on covariates.
#' @param mean.d Prior mean for the relative effect
#' @param prec.d Prior precision for the relative effect
#' @param mean.Eta Prior mean for the study effect (baseline risk)
#' @param prec.Eta Prior precision for the study effect (baseline risk)
#' @param hy.prior.Eta Between treatment heterogeneity in baseline risk (for exchangeable assumption only). Format of the parameter is same as hy.prior.
#' @param mean.bl Prior mean for the baseline slope
#' @param prec.bl Prior precision for the baseline slope
#' @param hy.prior.bl Between treatment heterogeneity in baseline slope (for exchangeable regression coefficient only). Format of the parameter is same as hy.prior.
#' @param mean.cov Prior mean for the covariate effect
#' @param prec.cov Prior precision for the covariate effect
#' @param hy.prior.cov Between treatment heterogeneity in covariate effect (for exchangeable regression coefficient only). Format of the parameter is same as hy.prior. Default is set to be dunif(0, 5) for binary, dunif(0, 100) for normal, and wishart with identity scale matrix and (# of categories - 1) degrees of freedom for multinomial.
#' @param hy.prior Prior for the heterogeneity parameter. Supports uniform, gamma, and half normal for normal and binomial response and wishart for multinomial response. It should be a list of length 3, where first element should be the distribution (one of dunif, dgamma, dhnorm, dwish) and the next two are the parameters associated with the distribution. For example, list("dunif", 0, 5) give uniform prior with lower bound 0 and upper bound 5 for the heterogeneity parameter. For wishart distribution, the last two parameter would be the scale matrix and the degrees of freedom.
#' @return Creates list of variables that are used to run the model using \code{\link{network.run}}
#' \item{data}{Data combining all the input data. User can check this to insure the data is correctly specified. For modelling purposes, character valued studies or treatment variables are changed to numeric values based on alphabetical order.}
#' \item{nrow}{Total number of arms in the meta-analysis}
#' \item{ncol}{Number of columns in the Outcomes. Will equal 1 for binary and normal and number of categories for multinomial}
#' \item{nstudy}{Number of study}
#' \item{na}{Number of arms for each study}
#' \item{ntreat}{Number of treatment}
#' \item{b.id}{Indicator in sequence of all treatments for which treatment is base treatment in Study}
#' \item{t}{\code{Treat} transformed into a matrix which has dimensions number of study by max number of arms in studies}
#' \item{r}{\code{Outcomes} made into an array that is suitable for use in rjags code. For multinomial, it has 3 dimensions: number of study by max number of arms in studies by number of categories.}
#' \item{mx}{If the continuous covariate is included, it calculates the mean of the covariates which is used to center the covariates. The numeric indicator after mx refers to column number of the covariates if there are more than one covariates included. Discrete covariates are not centered.}
#' \item{mx_bl}{If the baseline effect is specified, it also calculates the mean baseline risk.}
#' \item{prior.data}{Prior data created using the user inputs or default values. If no user input is specifies for the prior, it uses default values.}
#' \item{code}{Rjags model file code that is generated using information provided by the user. To view model file inside R in a nice format, use \code{cat(network$code).}}
#' @examples
#' ###Blocker data example
#' blocker
#' network <- with(blocker, {
#'  network.data(Outcomes, Study, Treat, N = N, response = "binomial")
#' })
#' network
#' @references S. Dias, A.J. Sutton, A.E. Ades, and N.J. Welton (2013a), \emph{A Generalized Linear Modeling Framework for Pairwise and Network Meta-analysis of Randomized Controlled Trials}, Medical Decision Making 33(5):607-617. [\url{https://doi.org/10.1177/0272989X12458724}]
#' @references F.A. Achana, N.J. Cooper, S. Dias, G. Lu, S.J.C. Rice, D. Kendrick, A.J. Sutton (2012), \emph{Extending methods for investigating the relationship between treatment effect and baseline risk from pairwise meta-analysis to network meta-analysis}, Statistics in Medicine 32(5):752-771. [\url{https://doi.org/10.1002/sim.5539}]
#' @references N.J. Cooper, A.J. Sutton, D. Morris, A.E. Ades, N.J. Welton (2009), \emph{Addressing between-study heterogeneity and inconsistency in mixed treatment comparisons: Application to stroke prevention treatments in individuals with non-rheumatic atrial fibrillation}, Statistics in Medicine 28:1861-1881. [\url{https://doi.org/10.1002/sim.3594}]
#' @export
network.data <- function(Outcomes = NULL, Study = NULL, Treat = NULL, N = NULL, SE = NULL, response = NULL, Treat.order = NULL, type = "random", rank.preference = "higher",
baseline = "none", baseline.risk = "independent", covariate = NULL, covariate.type = NULL, covariate.model = NULL,
mean.d = NULL, prec.d = NULL, mean.Eta = NULL, prec.Eta = NULL, hy.prior.Eta = NULL, mean.bl = NULL, prec.bl = NULL, hy.prior.bl = NULL,
mean.cov = NULL, prec.cov = NULL, hy.prior.cov = NULL, hy.prior = NULL) {
# rename the variables and order them based on specified treatment order
network <- preprocess.data(Outcomes = Outcomes, Study = Study, Treat = Treat, N = N, SE = SE, response = response, Treat.order = Treat.order, type = type, rank.preference = rank.preference,
baseline = baseline, baseline.risk = baseline.risk, covariate = covariate, covariate.type = covariate.type, covariate.model = covariate.model,
hy.prior.Eta = hy.prior.Eta, hy.prior.bl = hy.prior.bl, hy.prior.cov = hy.prior.cov, hy.prior = hy.prior)
# find characteristic values associated with the network, i.e. number of studies, number of treatments, etc
characteristics <- find.characteristics(network)
network <- append(network, characteristics)
# change input dimensions for Outcomes, Study, Treat, and N/SE to fit JAGS coding format
new.inputs <- change.dimensions(network)
network <- append(network, new.inputs)
# generate default priors for heterogeneity if not specified
hy.prior <- hy.prior.update(network, hy.prior.Eta, hy.prior.bl, hy.prior.cov, hy.prior)
network <- append(network, hy.prior)
# generate prior data that will be used for running JAGS model
prior.data <- network.prior.default(network, mean.d, prec.d, mean.Eta, prec.Eta, hy.prior.Eta, mean.bl, prec.bl, hy.prior.bl, mean.cov, prec.cov, hy.prior.cov, hy.prior)
network <- append(network, prior.data)
# generate JAGS code
code <- network.rjags(network)
network$code <- code
# calculate baseline log odds if baseline effect is specified
mx_bl <- calculate.baseline.log.odds(network)
network$mx_bl <- mx_bl
# calculate covariate mean if covariate is specified
cov.mean <- calculate.covariate.mean(network)
network <- append(network, cov.mean)
class(network) <- "network.data"
return(network)
}
change.dimensions <- function(network){
with(network, {
n <- se <- NULL
t <- make.byStudy.matrix(data[,"Treat"], data[,"Study"])
if(response == "binomial" || response == "multinomial"){
n <- make.byStudy.matrix(data[,"N"], data[,"Study"])
} else if(response == "normal"){
se <- make.byStudy.matrix(data[,"SE"], data[,"Study"])
}
r <- make.byStudy.Outcome(as.matrix(data[,1:ncol]), data[,"Study"], nstudy, na)
if(response != "multinomial"){
r <- r[,,1]
}
return(list(t = t, n = n, se = se, r = r))
})
}
find.characteristics <- function(network){
with(network,{
ncol <- dim(data)[2] - 3
nrow <- dim(data)[1]
nstudy <- length(Study.order)
ntreat <- length(Treat.order)
na <- rle(data[,"Study"])$lengths
ends <- cumsum(na) # End row of trials
starts <- c(1, ends[-length(ends)] + 1) # Start row of trials
b.Treat <- rep(NA, length(na))
b.id <- rep(F, sum(na))
for (i in 1:length(na)){
limits <- starts[i]:ends[i]
b.Treat[i] <- min(data[,"Treat"][limits])
b.id[limits[b.Treat[i] == data[,"Treat"][limits]]] <- T
}
return(list(ncol = ncol, nrow = nrow, nstudy = nstudy, ntreat = ntreat, na = na, b.id = b.id))
})
}
make.byStudy.Outcome = function(Outcomes, Study, nstudy, na){
r = structure(.Data = rep(NA, nstudy*max(na)* dim(Outcomes)[2]), .Dim = c(nstudy, max(na), dim(Outcomes)[2]))
arms_index = NULL
for(i in 1:length(na)){
arms_index = c(arms_index, seq(na[i]))
}
for(i in 1:dim(Outcomes)[1]){
r[Study[i],arms_index[i],] = Outcomes[i,]
}
return(r)
}
make.byStudy.matrix = function(Treat, Study){
#make the by-arms vector into a by-study matrix
nstudy = length(unique(Study))
na = rle(Study)$lengths
Study = rep(1:nstudy, times = na)
t = matrix(NA, nrow = nstudy, ncol = max(na))
arms_index = NULL
for(i in 1:length(na)){
arms_index = c(arms_index, seq(na[i]))
}
for(i in 1:length(Treat)){
t[Study[i], arms_index[i]] = Treat[i]
}
return(t)
}
calculate.baseline.log.odds <- function(network){
mx_bl <-
with(network,{
if(baseline %in% c("independent", "common", "exchangeable")){
if(response == "normal"){
mean(r[,1][t[,1]==1], na.rm = TRUE)
}
if(response == "binomial"){
rdummy = r[,1]
rdummy[r[,1] == 0] = 0.5
ndummy = n[,1]
ndummy[r[,1] == 0 & !is.na(r[,1])] = ndummy[r[,1] == 0 & !is.na(r[,1])] + 1
#take only the non-active control group (treatment A) to calculate the observed mean log odds
p = (rdummy[!is.na(rdummy)]/ndummy[!is.na(rdummy)]) #[t[,1][!is.na(rdummy)]==1]
lodds = log(p/(1-p))
mean(lodds, na.rm = TRUE)
}
if(response == "multinomial"){
#the first response in the multinomial is the reference, we will call it J
category = which(apply((miss.patterns[[2]]), 1, sum) == 1)
J = category[1]
#take only the control group
P_J = (r[,1,J]/n[,1])[t[,1]==1]
P_j = matrix(0, ncol = ncat-1, nrow = sum(t[,1]==1))
for(j in 2:ncat){
P_j[,j-1] = (r[,1,category[j]]/n[,1])[t[,1]==1]
}
lodds = log(P_j/P_J)
apply(lodds, 2, mean, na.rm = TRUE)
}
})
return(mx_bl)
}
calculate.covariate.mean <- function(network){
with(network,{
# calculate mean of covariate
store <- list()
if(!is.null(covariate)){
for(i in 1:dim(covariate)[2]){
nam <- paste("mx",i, sep = "")
nam <- assign(nam, mean(covariate[,i], na.rm = TRUE))
network[[paste("mx",i, sep = "")]] <- ifelse(covariate.type[i] == "continuous", nam, 0)
nam2 <- paste("x", i, sep = "")
nam2 <- assign(nam2, covariate[,i])
store[[paste("x", i, sep = "")]] <- nam2
}
}
return(store)
})
}
network
devtools::install_github("MikeJSeo/bnma")
devtools::install_github("MikeJSeo/bnma")
network <- with(blocker, {
network.data(Outcomes, Study, Treat, N = N, response = "binomial")
})
